<!doctype html>
<html lang="zh-CN">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="initial-scale=1.0, user-scalable=no, width=device-width">
    <title>数据结构与算法</title>

    <link rel="stylesheet" href="../00-static/base.css">
    <style>

    </style>

    <script src="../00-static/base.js"></script>

</head>
<body>

<pre>

    <h2 class="anchor">数据结构（data structure）-马老师</h2>
    存储数据的不同方式
        数组
        链表

    <h2 class="anchor">算法（algorithm）-马老师</h2>
    同一问题的不同解决方法
    算法往往是针对特定数据结构的
    测算算法优劣
        时间
        空间
    稳定性 如：数组中两个数相等，排序完成后，这些相等数的相对位置可能发生变化

    <h2 class="anchor">常见算法-马老师</h2>
          名称              平均O()      最坏O()        最好O()      空间复杂度      稳定性
    选择排序（Selection）      n^2         n^2           n^2            1          不稳
    冒泡排序（Bubble）         n^2         n^2            n             1          稳
    插入排序（Insertion）      n^2         n^2            n             1          稳
    堆排序（heap）         n*log_2`n    n*log_2`n     n*log_2`n         1          不稳
    希尔排序（Shell）        n^1.3         n^2            n             1          不稳
    归并排序（Merge）      n*log_2`n    n*log_2`n     n*log_2`n         n          稳
    快速排序（Quick）      n*log_2`n       n^2        n*log_2`n     n*log_2`n      不稳
    桶排序（Bucket）          n+k          n^2           n             n+k         稳
    计数排序（Counting）      n+k          n+k          n+k            n+k         稳
    基数排序（Radix）         n*k          n*k          n*k            n+k         稳

    希尔排序： 间隔插入排序
        间隔序列
            Knuth: h=1 h=3*h+1=4 h=3*4+1=13 ...

        例如：间隔取4， 则取 i%4 == 0 的为一组排序（仍在原数组，只不过下标间隔为4），
            排完之后在以间隔为2的排序，最终以间隔为1排序
            即 先将 0，4，8，12，。。。位置进行插入排序
              再将 0，2，4，6，8，。。。位置进行插入排序
              最后将 0，1，2，3，4，。。。位置进行插入排序

    归并排序：两个子数组（对半劈）排好顺序，然后合并到新数组，递归子数组
        过程：3个指针 两个子数组指针 一个新数组指针
            2个子数组指针后移比较 放到新数组 新数组指针后移

        java内部 对象排序（要求稳定）使用的是改进的归并排序 叫TIM SORT

    TIM SORT: 多路归并 先分多块 然后两两归并 再两两归并 。。。

    快速排序：单轴快排
        过程：找到一个轴，小于轴的放到左边大于轴的放到右边

    双轴快排：Arrays.sort(基础数据类型)



    进度 第10节 第2部分 00：00

    <h2 class="anchor">常识</h2>
    固定时间 --执行时间与数据无关
        常数操作: int a + int b, a b都是32位 不管数多大 都是同样的操作
        常见常数操作:
            + - * / >> >>> << | & ^ 赋值 比较 自增 自减 数组寻址(arr[10000]) ...
        数组(arr[])寻址: 内存中取 200万位置 与800万位置 是一样的时间
    非固定时间 --执行时间与数据有关
        LinkedList中 查找200万位置 与800万位置

    <h2 class="anchor">评估算法的优劣</h2>
    1 时间复杂度 流程决定
        排名: O(1) < O(logN=log 2 n) < O(N) < O(N*logN) < O(N^2) < O(N^3) < .. < O(N^k)
        < O(2^n) < O(3^n) < .. < O(k^n) < O(N!)
    2 额外空间复杂度 流程决定
    3 常数项时间(不重要) 实现细节决定
        例如 时间消耗 ^ 小于 + 远远小于 /

    <h2 class="anchor">时间复杂度O(?)</h2>
        常数操作O(1)的数量可以归纳为一个n(需要计算的n个数)的m次方的m阶方程式,
    例如a*n^m + b*n^(m-1) + ... + c*n + d, 则此算法的时间复杂度为O(n^m),
    读big O n的m次方,
        即 将过程拆分 确保拆分后的每一个操作都是时间固定的操作(例如常数操作),并
    可用f(n）函数表示,其中最大的指数级就是时间复杂度

    如: 选择排序,n个数  O(N^2)
        // 常数操作:交换 比较, 时间复杂度为O(1);
        // n-1次比较, 比较总共的复杂度为(n-1)*O(1)
        第1次循环 0~n-1 比较n-1次 与0位置交换 复杂度=(n-1)*O(1)+O(1)
        第2次循环 1~n-1 比较n-2次 与0位置交换 复杂度=(n-2)*O(1)+O(1)
        第3次循环 2~n-1 比较n-3次 与0位置交换 复杂度=(n-3)*O(1)+O(1)
        ...
        第n-2次循环 n-3~n-1 比较2次 与0位置交换 复杂度=2*O(1)+O(1)
        第n-1次循环 n-2~n-1 比较1次 与0位置交换 复杂度=1*O(1)+O(1)
        ||
        总共进行了f(n)=(n-1)+(n-2)+...+2+1次比较和n-1次交换,得出常数
        化简 f(n)=[(n-1)+1]*(n-1)/2=0.5*n^2+0.5*n
        加上交换n-1 的o(n) = 0.5n^2 + 1.5*n -1
        取最大指数 n^2 得出时间复杂度为O(n^2)

    <red>如果性能随数据状况变化,则取时间复杂度最差状况的值</red>
    例如 插入排序 a = [1,2,3,4,5,6,7]; b = [7,6,5,4,3,2,1] 取b的时间复杂度
        b第1次循环 2位置排序插入0~0位置 0~0只有一个数 有序             → [6,7,5,4,3,2,1]
        b第2次循环 3位置排序插入0~1位置 此时0~1位置经过上一次处理已经有序 → [5,6,7,4,3,2,1]
        b第3次循环 4位置排序插入0~2位置 此时0~2位置经过上一次处理已经有序 → [4,5,6,7,3,2,1]
        ...
        直到 → [1,2,3,4,5,6,7]

    二分法时间复杂度=log 2 n: n/2/2/2/2...

    <h2 class="anchor">额外空间复杂度</h2>
    除了数据的空间 和 算法需要返回的空间O(1), 算法过程中产生的其他空间叫额外空间
    固定个数的额外空间 = O(1); 其他 >= O(N)

    如
    给定arr[n] 要求算sum
        则int sum += arr[i]
        空间复杂度为O(1)
    给定arr[n] 要求统计每个数出现的次数
        假设使用了map保存每个数的个数,按最差的每个数只出现一次算
        空间复杂读为O(N)
    给定arr[n] 要求拷贝数据
        arr[n] ans
        空间复杂读为O(1)

    <h2 class="anchor">异或</h2>
    a^b: 二进制 相同为0 不同为1, 又叫无进位相加
    结论: 0^n=n n^n=0 a^b^c^....=a^c^b....(任意交换顺序都相等)
    例: a=6 b=7 不用额外变量交换
        a=a^b
        b=a^b
        a=a^b



    <h2 class="anchor">...</h2>
    体系班第二节 异或 51分

</pre>

</body>
</html>