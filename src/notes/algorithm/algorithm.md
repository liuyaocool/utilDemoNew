# 数据结构

1. 百度 Data Structure
2. geeksforgeeks.org
3. visualgo.net/zh

存储数据的不同方式 -- 数组,链表

- HashMap： 
  - 数组+链表(1.7) 
  - 数组+链表+红黑树(1.8)
    - 链表>=7 使用红黑树 泊松分布
- LinkedHashMap： 链表
- TreeMap： 红黑树

## ArrayList 动态扩容

## 连续数组

## 链表

## 树

## 二叉树

## AVL树

严格平衡二叉树

## 红黑树

## B-Tree

## B+Tree

## Hash表   (k,v)表

HashMap  增删改查 都是O(1) 但常数时间是比较大的

1. 按值传递：
   - String，Integer等包装类， 。。。
   - k，v都为String， 则hash表这条数据为 两个String相加的字节数
2. 按引用传递：非原生类型，如 new Person()， k为内存地址
   - k，v都为引用， 则hash表这条数据为 8+8=16字节

## 有序表

TreeMap  增删改查 都是logN

要求 key一定是可以比较的

1. firstKey   lastKey
2. floorKey(key)    --<=key的最近的key
3. ceilingKey(key)    -->=key的最近的key

## 跳表

ConcurrentSkipListMap

![](img\skip-table.png)

多加了索引链表

# 算法

- 同一问题的不同解决方法
- 算法往往是针对特定数据结构的
- 测算算法优劣
  - 时间
  - 空间
- 稳定性 如：数组中两个数相等，排序完成后，这些相等数的相对位置可能发生变化

## 常见排序算法

```
       名称                 平均O()      最坏O()        最好O()     空间复杂度    稳定性
    选择排序（Selection）      n^2         n^2           n^2            1         不稳
    冒泡排序（Bubble）         n^2         n^2            n             1         稳
    插入排序（Insertion）      n^2         n^2            n             1         稳
    堆排序（heap）         n*log_2`n    n*log_2`n     n*log_2`n         1         不稳
    希尔排序（Shell）        n^1.3         n^2            n             1         不稳
    归并排序（Merge）      n*log_2`n    n*log_2`n     n*log_2`n         n         稳
    快速排序（Quick）      n*log_2`n       n^2        n*log_2`n     n*log_2`n     不稳
    桶排序（Bucket）          n+k          n^2           n             n+k        稳
    计数排序（Counting）      n+k          n+k          n+k            n+k        稳
    基数排序（Radix）         n*k          n*k          n*k            n+k        稳
```

1. 希尔排序： 间隔插入排序
   -  间隔序列Knuth： h=1 h=3*h+1=4 h=3*4+1=13 ...
   - 例如：间隔取4， 则取 i%4 == 0 的为一组排序（仍在原数组，只不过下标间隔为4），排完之后在以间隔为2的排序，最终以间隔为1排序
     - 即 先将 0，4，8，12，。。。位置进行插入排序
     - 再将 0，2，4，6，8，。。。位置进行插入排序
     - 最后将 0，1，2，3，4，。。。位置进行插入排序
2. 归并排序：两个子数组（对半劈）排好顺序，然后合并到新数组，递归子数组
   - 过程：3个指针 两个子数组指针 一个新数组指针，2个子数组指针后移比较 放到新数组 新数组指针后移
3. TIM SORT
   - java内部 对象排序（要求稳定）使用的是改进的归并排序 叫TIM SORT
   - 多路归并 先分多块 然后两两归并 再两两归并 。。。
4. 快速排序：单轴快排
   - 过程：找到一个轴，小于轴的放到左边大于轴的放到右边
5. 双轴快排：Arrays.sort(基础数据类型)

# 常识
## 固定时间

执行时间与数据无关

常数操作: int a + int b, a b都是32位 不管数多大 都是同样的操作，常见常数操作：

```
+ - * / >> >>> << | & ^ 赋值 比较 自增 自减 数组寻址(arr[10000]) ...
## 数组(arr[])寻址: 内存中取 200万位置 与800万位置 是一样的时间
```

## 非固定时间

执行时间与数据有关，如 LinkedList中 查找200万位置 与800万位置

# 评估算法的优劣

1. 时间复杂度 流程决定，排名：

   ```
   O(1) < O(logN=log 2 n) < O(N) < O(N*logN) < O(N^2) < O(N^3) < .. < O(N^k) < O(2^n) < O(3^n) < .. < O(k^n) < O(N!)
   ```

2. 额外空间复杂度 流程决定

3. 常数项时间(不重要) 实现细节决定

   - 例如：^ < + <<< /

# 时间复杂度O(?)

​	常数操作O(1)的数量可以归纳为一个n(需要计算的n个数)的m次方的m阶方程式，例如a*n^m + b*n^(m-1) + ... + c*n + d，则此算法的时间复杂度为O(n^m)，读big O n的m次方。

​	即 将过程拆分 确保拆分后的每一个操作都是**时间固定**的操作(例如常数操作)，并可用f(n）函数表示,其中**最大的指数级**就是时间复杂度

**如: 选择排序,n个数  O(N^2)**
    // 常数操作:交换 比较, 时间复杂度为O(1);
    // n-1次比较, 比较总共的复杂度为(n-1)*O(1)
    第1次循环 0~n-1 比较n-1次 与0位置交换 复杂度=(n-1)*O(1)+O(1)
    第2次循环 1~n-1 比较n-2次 与0位置交换 复杂度=(n-2)*O(1)+O(1)
    第3次循环 2~n-1 比较n-3次 与0位置交换 复杂度=(n-3)*O(1)+O(1)
    ...
    第n-2次循环 n-3~n-1 比较2次 与0位置交换 复杂度=2*O(1)+O(1)
    第n-1次循环 n-2~n-1 比较1次 与0位置交换 复杂度=1*O(1)+O(1)
    ||
    总共进行了f(n)=(n-1)+(n-2)+...+2+1次比较和n-1次交换,得出常数
    化简 f(n)=[(n-1)+1]*(n-1)/2=0.5*n^2+0.5*n
    加上交换n-1 的o(n) = 0.5n^2 + 1.5*n -1
    取最大指数 n^2 得出时间复杂度为O(n^2)

**<u>如果性能随数据状况变化，则取时间复杂度最差状况的值</u>**
**例如 插入排序 a = [1,2,3,4,5,6,7]；b = [7,6,5,4,3,2,1] 取b的时间复杂度**
    b第1次循环 2位置排序插入0~0位置 0~0只有一个数 有序             → [6,7,5,4,3,2,1]
    b第2次循环 3位置排序插入0~1位置 此时0~1位置经过上一次处理已经有序 → [5,6,7,4,3,2,1]
    b第3次循环 4位置排序插入0~2位置 此时0~2位置经过上一次处理已经有序 → [4,5,6,7,3,2,1]
    ...
    直到 → [1,2,3,4,5,6,7]

**二分法时间复杂度:**  log 2 n    --n/2/2/2/2...

# 额外空间复杂度
除了数据的空间 和 算法需要返回的空间O(1), 算法过程中产生的其他空间叫额外空间固定个数的额外空间 = O(1); 其他 >= O(N)

**如**
给定arr[n] 要求算sum
    则int sum += arr[i]
    空间复杂度为O(1)
给定arr[n] 要求统计每个数出现的次数
    假设使用了map保存每个数的个数,按最差的每个数只出现一次算
    空间复杂读为O(N)
给定arr[n] 要求拷贝数据
    arr[n] ans
    空间复杂读为O(1)

# 技巧

## 位操作

1. 带符号左移 <<
2. 带符号右移 >>
3. 无符号右移 >>>
4. 与 &：同1为1 否则为0
5. 或 | ：有1为1
6. 异或  ^： 相同为0 不同为1，又叫无进位相加
   - 结论：0^n=n； n^n=0； a^b^c^....=a^c^b....(任意交换顺序都相等)
   - 例：a=6，b=7，不使用额外变量进行交换
         a=a^b
         b=a^b
         a=a^b







# 进度

马老师：10.2 00:00:00

新手：04 00:39:00

基础：01 00:00:00

进阶：01 00:00:00

体系：01 00:00:00